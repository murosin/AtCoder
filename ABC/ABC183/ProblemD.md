[問題へのLink (ABC183 [ProblemD])](https://atcoder.jp/contests/abc183/tasks/abc183_d)
### 費やした回答時間：約20分 ###
### Source Code ###
```
N, W = map(int,input().split())
plan = [0] * (2 * pow(10,5) + 1)
for i in range(N):
  s, t, p = map(int,input().split())
  plan[s] -= p
  plan[t] += p
  
temp = 0
for i in range(2 * pow(10,5)):
  temp += plan[i]
  if -1 * temp > W:
    print('No')
    exit()
print('Yes')
```
### Idea ###
はじめは各分で利用予定の量に関する配列を用意し、利用予定の情報を得るたびに配列を変更し、変更後の最小値×-1とWとを比較することを考えていた。  
つまり、「1分から3分まで2L使う」予定と「2分から4分まで3L使う」予定があったとき、配列A(初期は[0,0,0,...])を
A[0,-2,-2,0,0,...]->A[0,-2,-5,-3,0,0,...]というように変更させていき、変更がすべて終了したこの配列の最小値×-1とWとを比較することを考えていた。
しかし、予定数Nが最大の2×10^5であり、かつ全ての利用予定が0分～2×10^5分までの予定であれば、配列の変更だけで10^10以上のループ処理が必要となる。  
よって、配列の変更は利用開始時と終了時のみ記録することとした。つまり先ほどの例では、A[0,-2,0,+2,0,0,...]->A[0,-2,-3,+2,+3,0,0,...]となる。  
これにより配列の変更自体はすぐ終わり、変化に応じてその分における利用予定量も簡単に計算できる。  
### Details ###
##### sample1 #####
```
4 10
1 3 5
2 4 4
3 10 6
2 4 1
```

1. 入力処理＆利用予定の配列作成
```
N, W = map(int,input().split())
plan = [0] * (2 * pow(10,5) + 1)
for i in range(N):
  s, t, p = map(int,input().split())
  plan[s] -= p
  plan[t] += p

-----
N=4
W=10
plan=[0, -5, -5, -1, 5, 0, 0, 0, 0, 0, 6, 0, 0, 0,...]
```
2. 各分での利用予定量を計算し、Wを越えれば'No'、最後まで越えなければ'Yes'を出力して終了する。
```
temp = 0
for i in range(2 * pow(10,5)):
  temp += plan[i]
  if -1 * temp > W:
    print('No')
    exit()
print('Yes')
```
### Impression ###
今まで取り組んだD問題の中では最も早く解けた。


